/**********************************************************************
 *                                                                    *
 * Created by Adam Brockett                                           *
 *                                                                    *
 * Copyright (c) 2010                                                 *
 *                                                                    *
 * Redistribution and use in source and binary forms, with or without *
 * modification is allowed.                                           *
 *                                                                    *
 * But if you let me know you're using my code, that would be freaking*
 * sweet.                                                             *
 *                                                                    *
 **********************************************************************/

// Taken from: https://github.com/gilgad13/rsa-gmp

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <gmp.h>
#include <sys/random.h>
#include <stdint.h>

#define MAX_BYTES 1024
#define MAX_BIT_LEN (MAX_BYTES * CHAR_BIT)

#define MODULUS_SIZE 1024                   /* This is the number of bits we want in the modulus */
#define BLOCK_SIZE (MODULUS_SIZE/8)         /* This is the size of a block that gets en/decrypted at once */
#define BUFFER_SIZE ((MODULUS_SIZE/8) / 2)  /* This is the number of bytes in n and p */

typedef struct {
    mpz_t n; 
    mpz_t e;
} public_key_t;

typedef struct {
    mpz_t n; 
    mpz_t d; 
} private_key_t;

void fill_random(char* buf, size_t len) {
  size_t filled = 0;
  while (filled < len) {
    filled += getrandom(buf + filled, len - filled, 0);
  }
}

void random_mpz_bits(mpz_t out, int bits) {
  char buf[MAX_BYTES];
  int bytes = bits / CHAR_BIT + (bits % CHAR_BIT == 0 ? 0 : 1);
  fill_random(buf, bytes);
  int good_top_bits = bits % CHAR_BIT;
  if (good_top_bits == 0) { good_top_bits = CHAR_BIT; }
  char high_mask = ~(-1 << good_top_bits);
  buf[0] &= high_mask;
  mpz_import(out, bytes, 1, sizeof(buf[0]), 0, 0, buf);
}

void probable_prime(mpz_t x, int bits) {
  mpz_t temp;
  mpz_init(temp);
  random_mpz_bits(temp, bits);
  // Set the top bit
  mpz_setbit(temp, bits - 1);
  // Set the bottom bit to 1 so it is odd
  mpz_setbit(temp, 0);
  
  mpz_nextprime(x, temp);
  mpz_clear(temp);
}

// Generates a random value from the range [min, max)
void random_mpz(mpz_t out, mpz_t min, mpz_t max) {
  mpz_t interval_size;
  mpz_init(interval_size);
  mpz_sub(interval_size, max, min);
  size_t bits = mpz_sizeinbase(interval_size, 2);
  do {
    random_mpz_bits(out, bits);
  } while (mpz_cmp(interval_size, out) <= 0);
  mpz_add(out, out, min);
}

void print_hex(char* arr, int len) {
  for(int i = 0; i < len; i++) {
    printf("%02x", (unsigned char) arr[i]); 
  }
}

/* NOTE: Assumes mpz_t's are initted in ku and kp */
void generate_keys(private_key_t* ku, public_key_t* kp, int bits) {
    mpz_t phi;
    mpz_init(phi);
    mpz_t two;
    mpz_init_set_si(two, 2);

    mpz_t p, q;
    mpz_inits(p, q);

    do {
      probable_prime(p, bits / 2);
      probable_prime(q, bits / 2);
      mpz_mul(ku->n, p, q);

      mpz_sub_ui(p, p, 1);
      mpz_sub_ui(q, q, 1);
      mpz_mul(phi, p, q);
    } while (mpz_cmp_si(phi, 2) <= 0);
    mpz_set(kp->n, ku->n);

    mpz_t gcd;
    mpz_init(gcd);
    do {
      random_mpz(kp->e, two, phi);
      mpz_gcd(gcd, kp->e, phi);
    } while(mpz_cmp_si(gcd, 1) != 0);
    mpz_clear(gcd);

    mpz_invert(ku->d, kp->e, phi);
    
    mpz_clear(phi);
    mpz_clear(two);
}

void block_encrypt(mpz_t C, mpz_t M, public_key_t kp)
{
    /* C = M^e mod n */
    mpz_powm(C, M, kp.e, kp.n); 
    return;
}

int encrypt(char cipher[], char message[], int length, public_key_t kp)
{
    /* Its probably overkill, but I implemented PKCS#1v1.5 paging
     * Encoded message block is of the form:
     * EMB = 00 || 02 || PS || 00 || D
     * Where || is concatenation, D is the message, and PS is a string of
     * (block_size-|D|-3) non-zero, randomly generated bytes
     * |D| must be less than block_size - 11, which means we have at least 8
     * bytes of PS
     */
    int block_count = 0;
    int prog = length;
    char rand_buf[BLOCK_SIZE];
    char mess_block[BLOCK_SIZE];
    mpz_t m; mpz_init(m);
    mpz_t c; mpz_init(c);

    while(prog > 0)
    {
        int d_len = (prog >= (BLOCK_SIZE - 11)) ? BLOCK_SIZE - 11 : prog;
        
        int i = 0;
        /* Construct the header */
        mess_block[i++] = 0x00;
        mess_block[i++] = 0x02;
        fill_random(rand_buf, BLOCK_SIZE-d_len-1);
        for(; i < (BLOCK_SIZE - d_len - 1); i++) {
            mess_block[i] = (rand_buf[i] % (0xFF - 1)) + 1; 
        }
        mess_block[i++] = 0x00;

        /* Copy in the message */
        memcpy(mess_block + i, message + (length - prog), d_len);
        
        // Convert bytestream to integer 
        mpz_import(m, BLOCK_SIZE, 1, sizeof(mess_block[0]), 0, 0, mess_block);
        // Perform encryption on that block
        block_encrypt(c, m, kp);

        // Calculate cipher write offset to take into account that we want to
        // pad with zeros in the front if the number we get back has fewer bits
        // than BLOCK_SIZE
        int off = block_count * BLOCK_SIZE;         // Base offset to start of this block
        off += (BLOCK_SIZE - (mpz_sizeinbase(c, 2) + 8 - 1)/8); // See manual for mpz_export
        
        // Pull out bytestream of ciphertext
        mpz_export(cipher + off, NULL, 1, sizeof(char), 0, 0, c);

        block_count++;
        prog -= d_len;
    }
    return block_count * BLOCK_SIZE;
} 

void block_decrypt(mpz_t M, mpz_t C, private_key_t ku)
{
    mpz_powm(M, C, ku.d, ku.n); 
    return;
}

int decrypt(char* message, char* cipher, int length, private_key_t ku)
{
    int msg_idx = 0;
    char buf[BLOCK_SIZE];
    *(long long*)buf = 0ll;
    mpz_t c; mpz_init(c);
    mpz_t m; mpz_init(m);

    int i;
    for(i = 0; i < (length / BLOCK_SIZE); i++)
    {
        // Pull block into mpz_t
        mpz_import(c, BLOCK_SIZE, 1, sizeof(char), 0, 0, cipher + i * BLOCK_SIZE);
        // Decrypt block
        block_decrypt(m, c, ku);

        // Calculate message write offset to take into account that we want to
        // pad with zeros in the front if the number we get back has fewer bits
        // than BLOCK_SIZE
        int off = (BLOCK_SIZE - (mpz_sizeinbase(m, 2) + 8 - 1)/8); // See manual for mpz_export
        // Convert back to bitstream
        mpz_export(buf + off, NULL, 1, sizeof(char), 0, 0, m);

        // Now we just need to lop off top padding before memcpy-ing to message
        // We know the first 2 bytes are 0x00 and 0x02, so manually skip those
        // After that, increment forward till we see a zero byte
        int j;
        for(j = 2; ((buf[j] != 0) && (j < BLOCK_SIZE)); j++);
        j++;        // Skip the 00 byte

        /* Copy over the message part of the plaintext to the message return var */
        memcpy(message + msg_idx, buf + j, BLOCK_SIZE - j);

        msg_idx += BLOCK_SIZE - j; 
    } 
    return msg_idx;
}

int main()
{
    mpz_t M;  mpz_init(M);
    mpz_t C;  mpz_init(C);
    mpz_t DC;  mpz_init(DC);
    private_key_t ku;
    public_key_t kp;

    // Initialize public key
    mpz_init(kp.n);
    mpz_init(kp.e); 
    // Initialize private key
    mpz_init(ku.n); 
    mpz_init(ku.d); 

    generate_keys(&ku, &kp, 1024);
    printf("---------------Private Key-----------------");
    printf("kp.n is\n%s\n", mpz_get_str(NULL, 16, kp.n));
    printf("kp.e is\n%s\n", mpz_get_str(NULL, 16, kp.e));
    printf("---------------Public Key------------------");
    printf("ku.n is\n%s\n", mpz_get_str(NULL, 16, ku.n));
    printf("ku.d is\n%s\n", mpz_get_str(NULL, 16, ku.d));

    printf("bitlen(n) = %lu\n", mpz_sizeinbase(kp.n, 2));

    char buf[127]; 
    fill_random(buf, sizeof(buf));

    mpz_import(M, sizeof(buf), 1, sizeof(buf[0]), 0, 0, buf);
    printf("original is\n%s\n", mpz_get_str(NULL, 62, M)); 
    block_encrypt(C, M, kp);
    printf("encrypted is\n%s\n", mpz_get_str(NULL, 62, C));
    block_decrypt(DC, C, ku);
    printf("decrypted is\n%s\n", mpz_get_str(NULL, 62, DC));
    return 0;
}
